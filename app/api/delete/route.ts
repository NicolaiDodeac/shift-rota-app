// export const runtime = "nodejs";
// export const dynamic = "force-dynamic";
// import { NextResponse } from "next/server";
// import { calendarClient, findCalendarIdBySummary } from "@/lib/google";
// import { auth } from "@/auth";

// export async function POST(req: Request) {
//   const session = await auth();
//   if (!session) {
//     return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
//   }
//   const { start, end, useDedicatedCalendar, dedicatedCalendarName } =
//     await req.json();
//   if (!start || !end)
//     return NextResponse.json(
//       { message: "start and end are required (YYYY-MM-DD)" },
//       { status: 400 }
//     );

//   const { accessToken, refreshToken } = session as any;
//   const cal = calendarClient(accessToken, refreshToken);

//   let calendarId = "primary";
//   if (useDedicatedCalendar) {
//     const name = dedicatedCalendarName || "Shift Rota";
//     const found = await findCalendarIdBySummary(cal, name);
//     if (!found)
//       return NextResponse.json({
//         deleted: 0,
//         note: "Dedicated calendar not found",
//       });
//     calendarId = found;
//   }

//   // We target events our app created (by description text)
//   const query = "Generated by Shift Rota"; // adjust if you changed description
//   let deleted = 0,
//     pageToken: string | undefined = undefined;

//   do {
//     const res: any = await cal.events.list({
//       calendarId,
//       timeMin: new Date(start + "T00:00:00Z").toISOString(),
//       timeMax: new Date(end + "T23:59:59Z").toISOString(),
//       singleEvents: true,
//       maxResults: 2500,
//       pageToken,
//       q: query,
//     });
//     const items = res.data.items || [];
//     for (const ev of items) {
//       if (!ev.id) continue;
//       try {
//         await cal.events.delete({ calendarId, eventId: ev.id });
//         deleted++;
//       } catch (e) {
//         console.error("Delete failed", ev.id, e);
//       }
//     }
//     pageToken = res.data.nextPageToken || undefined;
//   } while (pageToken);

//   return NextResponse.json({ deleted, calendarId });
// }

import { NextResponse } from "next/server";
import { auth } from "@/auth";
import { z } from "zod";
import { calendarClient, ensureCalendarId } from "@/lib/google";
import { prisma } from "@/lib/db";
import { getOrCreateUserByEmail } from "@/lib/users";
import { DateTime } from "luxon";

const BodySchema = z.object({
  start: z.string(), // 'YYYY-MM-DD'
  end: z.string(), // 'YYYY-MM-DD'
  useDedicatedCalendar: z.boolean().optional(),
  dedicatedCalendarName: z.string().optional(),
});

export async function POST(req: Request) {
  const session = await auth();
  if (!session?.user?.email) {
    return NextResponse.json({ message: "Unauthorized" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = BodySchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ message: "Invalid payload" }, { status: 400 });
  }

  const email = session.user.email;
  const user = await getOrCreateUserByEmail(email);

  const anySession = session as any;
  const calendar = calendarClient(
    anySession.accessToken,
    anySession.refreshToken
  );

  let calendarId = "primary";
  if (parsed.data.useDedicatedCalendar) {
    calendarId = await ensureCalendarId(
      calendar,
      parsed.data.dedicatedCalendarName || "Shift Rota",
      "11"
    );
  }

  // Delete from Google Calendar
  const timeMin = new Date(parsed.data.start + "T00:00:00Z").toISOString();
  const timeMax = new Date(parsed.data.end + "T23:59:59Z").toISOString();

  let deleted = 0;
  const events = await calendar.events.list({
    calendarId,
    timeMin,
    timeMax,
    singleEvents: true,
  });
  for (const item of events.data.items ?? []) {
    if (!item.id) continue;
    try {
      await calendar.events.delete({ calendarId, eventId: item.id });
      deleted++;
    } catch (e) {
      console.warn("Delete failed for", item.id, e);
    }
  }

  // Delete from our DB
  const tz =
    (await prisma.settings.findUnique({ where: { userId: user.id } }))?.tz ||
    "Europe/London";
  const startUTC = DateTime.fromISO(parsed.data.start, { zone: tz })
    .startOf("day")
    .toUTC();
  const endUTC = DateTime.fromISO(parsed.data.end, { zone: tz })
    .endOf("day")
    .toUTC();

  const dbDel = await prisma.shiftInstance.deleteMany({
    where: {
      userId: user.id,
      startUTC: { gte: startUTC.toJSDate(), lte: endUTC.toJSDate() },
    },
  });

  return NextResponse.json({ deleted, dbDeleted: dbDel.count, calendarId });
}
